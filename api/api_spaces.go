// Copyright 2023 GitBook, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gitbook

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SpacesApiService SpacesApi service
type SpacesApiService service

type SpacesApiCreateChangeRequestRequest struct {
	ctx                        context.Context
	ApiService                 *SpacesApiService
	spaceId                    string
	requestCreateChangeRequest *RequestCreateChangeRequest
}

func (r SpacesApiCreateChangeRequestRequest) RequestCreateChangeRequest(requestCreateChangeRequest RequestCreateChangeRequest) SpacesApiCreateChangeRequestRequest {
	r.requestCreateChangeRequest = &requestCreateChangeRequest
	return r
}

func (r SpacesApiCreateChangeRequestRequest) Execute() (*CreateChangeRequest201Response, *http.Response, error) {
	return r.ApiService.CreateChangeRequestExecute(r)
}

/*
CreateChangeRequest Create a new change request for a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiCreateChangeRequestRequest
*/
func (a *SpacesApiService) CreateChangeRequest(ctx context.Context, spaceId string) SpacesApiCreateChangeRequestRequest {
	return SpacesApiCreateChangeRequestRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return CreateChangeRequest201Response
func (a *SpacesApiService) CreateChangeRequestExecute(r SpacesApiCreateChangeRequestRequest) (*CreateChangeRequest201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateChangeRequest201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.CreateChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestCreateChangeRequest == nil {
		return localVarReturnValue, nil, reportError("requestCreateChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestCreateChangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiCreateSpaceRequest struct {
	ctx                context.Context
	ApiService         *SpacesApiService
	organizationId     string
	requestCreateSpace *RequestCreateSpace
}

func (r SpacesApiCreateSpaceRequest) RequestCreateSpace(requestCreateSpace RequestCreateSpace) SpacesApiCreateSpaceRequest {
	r.requestCreateSpace = &requestCreateSpace
	return r
}

func (r SpacesApiCreateSpaceRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.CreateSpaceExecute(r)
}

/*
CreateSpace Create an organization space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The unique id of the organization
	@return SpacesApiCreateSpaceRequest
*/
func (a *SpacesApiService) CreateSpace(ctx context.Context, organizationId string) SpacesApiCreateSpaceRequest {
	return SpacesApiCreateSpaceRequest{
		ApiService:     a,
		ctx:            ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//
//	@return Space
func (a *SpacesApiService) CreateSpaceExecute(r SpacesApiCreateSpaceRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.CreateSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{organizationId}/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestCreateSpace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiCreateSpaceRelationRequest struct {
	ctx                        context.Context
	ApiService                 *SpacesApiService
	spaceId                    string
	createSpaceRelationRequest *CreateSpaceRelationRequest
}

func (r SpacesApiCreateSpaceRelationRequest) CreateSpaceRelationRequest(createSpaceRelationRequest CreateSpaceRelationRequest) SpacesApiCreateSpaceRelationRequest {
	r.createSpaceRelationRequest = &createSpaceRelationRequest
	return r
}

func (r SpacesApiCreateSpaceRelationRequest) Execute() (*SpaceRelation, *http.Response, error) {
	return r.ApiService.CreateSpaceRelationExecute(r)
}

/*
CreateSpaceRelation Create a new relation between a source space and a target space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiCreateSpaceRelationRequest
*/
func (a *SpacesApiService) CreateSpaceRelation(ctx context.Context, spaceId string) SpacesApiCreateSpaceRelationRequest {
	return SpacesApiCreateSpaceRelationRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return SpaceRelation
func (a *SpacesApiService) CreateSpaceRelationExecute(r SpacesApiCreateSpaceRelationRequest) (*SpaceRelation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpaceRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.CreateSpaceRelation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSpaceRelationRequest == nil {
		return localVarReturnValue, nil, reportError("createSpaceRelationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSpaceRelationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiDeleteCommentInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	commentId       string
}

func (r SpacesApiDeleteCommentInChangeRequestRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentInChangeRequestExecute(r)
}

/*
DeleteCommentInChangeRequest Delete a comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@return SpacesApiDeleteCommentInChangeRequestRequest
*/
func (a *SpacesApiService) DeleteCommentInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string) SpacesApiDeleteCommentInChangeRequestRequest {
	return SpacesApiDeleteCommentInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
	}
}

// Execute executes the request
func (a *SpacesApiService) DeleteCommentInChangeRequestExecute(r SpacesApiDeleteCommentInChangeRequestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DeleteCommentInChangeRequest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiDeleteCommentInSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	commentId  string
}

func (r SpacesApiDeleteCommentInSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentInSpaceExecute(r)
}

/*
DeleteCommentInSpace Delete a comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@return SpacesApiDeleteCommentInSpaceRequest
*/
func (a *SpacesApiService) DeleteCommentInSpace(ctx context.Context, spaceId string, commentId string) SpacesApiDeleteCommentInSpaceRequest {
	return SpacesApiDeleteCommentInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		commentId:  commentId,
	}
}

// Execute executes the request
func (a *SpacesApiService) DeleteCommentInSpaceExecute(r SpacesApiDeleteCommentInSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DeleteCommentInSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiDeleteCommentReplyInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	commentId       string
	commentReplyId  string
}

func (r SpacesApiDeleteCommentReplyInChangeRequestRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentReplyInChangeRequestExecute(r)
}

/*
DeleteCommentReplyInChangeRequest Delete a comment reply in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiDeleteCommentReplyInChangeRequestRequest
*/
func (a *SpacesApiService) DeleteCommentReplyInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string, commentReplyId string) SpacesApiDeleteCommentReplyInChangeRequestRequest {
	return SpacesApiDeleteCommentReplyInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
		commentReplyId:  commentReplyId,
	}
}

// Execute executes the request
func (a *SpacesApiService) DeleteCommentReplyInChangeRequestExecute(r SpacesApiDeleteCommentReplyInChangeRequestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DeleteCommentReplyInChangeRequest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiDeleteCommentReplyInSpaceRequest struct {
	ctx            context.Context
	ApiService     *SpacesApiService
	spaceId        string
	commentId      string
	commentReplyId string
}

func (r SpacesApiDeleteCommentReplyInSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentReplyInSpaceExecute(r)
}

/*
DeleteCommentReplyInSpace Delete a comment reply in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiDeleteCommentReplyInSpaceRequest
*/
func (a *SpacesApiService) DeleteCommentReplyInSpace(ctx context.Context, spaceId string, commentId string, commentReplyId string) SpacesApiDeleteCommentReplyInSpaceRequest {
	return SpacesApiDeleteCommentReplyInSpaceRequest{
		ApiService:     a,
		ctx:            ctx,
		spaceId:        spaceId,
		commentId:      commentId,
		commentReplyId: commentReplyId,
	}
}

// Execute executes the request
func (a *SpacesApiService) DeleteCommentReplyInSpaceExecute(r SpacesApiDeleteCommentReplyInSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DeleteCommentReplyInSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiDeleteSpaceRelationRequest struct {
	ctx           context.Context
	ApiService    *SpacesApiService
	spaceId       string
	targetSpaceId string
}

func (r SpacesApiDeleteSpaceRelationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSpaceRelationExecute(r)
}

/*
DeleteSpaceRelation Delete a relation between spaces

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param targetSpaceId The ID of the other space
	@return SpacesApiDeleteSpaceRelationRequest
*/
func (a *SpacesApiService) DeleteSpaceRelation(ctx context.Context, spaceId string, targetSpaceId string) SpacesApiDeleteSpaceRelationRequest {
	return SpacesApiDeleteSpaceRelationRequest{
		ApiService:    a,
		ctx:           ctx,
		spaceId:       spaceId,
		targetSpaceId: targetSpaceId,
	}
}

// Execute executes the request
func (a *SpacesApiService) DeleteSpaceRelationExecute(r SpacesApiDeleteSpaceRelationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DeleteSpaceRelation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/relations/{targetSpaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetSpaceId"+"}", url.PathEscape(parameterValueToString(r.targetSpaceId, "targetSpaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiDuplicateSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiDuplicateSpaceRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.DuplicateSpaceExecute(r)
}

/*
DuplicateSpace Create a duplicate of the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiDuplicateSpaceRequest
*/
func (a *SpacesApiService) DuplicateSpace(ctx context.Context, spaceId string) SpacesApiDuplicateSpaceRequest {
	return SpacesApiDuplicateSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return Space
func (a *SpacesApiService) DuplicateSpaceExecute(r SpacesApiDuplicateSpaceRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.DuplicateSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiExportToGitRepositoryRequest struct {
	ctx                          context.Context
	ApiService                   *SpacesApiService
	spaceId                      string
	requestExportToGitRepository *RequestExportToGitRepository
}

func (r SpacesApiExportToGitRepositoryRequest) RequestExportToGitRepository(requestExportToGitRepository RequestExportToGitRepository) SpacesApiExportToGitRepositoryRequest {
	r.requestExportToGitRepository = &requestExportToGitRepository
	return r
}

func (r SpacesApiExportToGitRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportToGitRepositoryExecute(r)
}

/*
ExportToGitRepository Export the space content to a Git repository.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiExportToGitRepositoryRequest
*/
func (a *SpacesApiService) ExportToGitRepository(ctx context.Context, spaceId string) SpacesApiExportToGitRepositoryRequest {
	return SpacesApiExportToGitRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *SpacesApiService) ExportToGitRepositoryExecute(r SpacesApiExportToGitRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ExportToGitRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/git/export"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestExportToGitRepository == nil {
		return nil, reportError("requestExportToGitRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestExportToGitRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiGetChangeRequestByIdRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
}

func (r SpacesApiGetChangeRequestByIdRequest) Execute() (*ChangeRequest, *http.Response, error) {
	return r.ApiService.GetChangeRequestByIdExecute(r)
}

/*
GetChangeRequestById Get the change request with the given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiGetChangeRequestByIdRequest
*/
func (a *SpacesApiService) GetChangeRequestById(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiGetChangeRequestByIdRequest {
	return SpacesApiGetChangeRequestByIdRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return ChangeRequest
func (a *SpacesApiService) GetChangeRequestByIdExecute(r SpacesApiGetChangeRequestByIdRequest) (*ChangeRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChangeRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetChangeRequestById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSpaceGitInfo404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetCommentInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	commentId       string
	format          *string
}

// Output format for the content.
func (r SpacesApiGetCommentInChangeRequestRequest) Format(format string) SpacesApiGetCommentInChangeRequestRequest {
	r.format = &format
	return r
}

func (r SpacesApiGetCommentInChangeRequestRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.GetCommentInChangeRequestExecute(r)
}

/*
GetCommentInChangeRequest Get a comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@return SpacesApiGetCommentInChangeRequestRequest
*/
func (a *SpacesApiService) GetCommentInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string) SpacesApiGetCommentInChangeRequestRequest {
	return SpacesApiGetCommentInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) GetCommentInChangeRequestExecute(r SpacesApiGetCommentInChangeRequestRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetCommentInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetCommentInSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	commentId  string
	format     *string
}

// Output format for the content.
func (r SpacesApiGetCommentInSpaceRequest) Format(format string) SpacesApiGetCommentInSpaceRequest {
	r.format = &format
	return r
}

func (r SpacesApiGetCommentInSpaceRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.GetCommentInSpaceExecute(r)
}

/*
GetCommentInSpace Get a comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@return SpacesApiGetCommentInSpaceRequest
*/
func (a *SpacesApiService) GetCommentInSpace(ctx context.Context, spaceId string, commentId string) SpacesApiGetCommentInSpaceRequest {
	return SpacesApiGetCommentInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) GetCommentInSpaceExecute(r SpacesApiGetCommentInSpaceRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetCommentInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetCommentReplyInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	commentId       string
	commentReplyId  string
	format          *string
}

// Output format for the content.
func (r SpacesApiGetCommentReplyInChangeRequestRequest) Format(format string) SpacesApiGetCommentReplyInChangeRequestRequest {
	r.format = &format
	return r
}

func (r SpacesApiGetCommentReplyInChangeRequestRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.GetCommentReplyInChangeRequestExecute(r)
}

/*
GetCommentReplyInChangeRequest Get a comment reply in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiGetCommentReplyInChangeRequestRequest
*/
func (a *SpacesApiService) GetCommentReplyInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string, commentReplyId string) SpacesApiGetCommentReplyInChangeRequestRequest {
	return SpacesApiGetCommentReplyInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
		commentReplyId:  commentReplyId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) GetCommentReplyInChangeRequestExecute(r SpacesApiGetCommentReplyInChangeRequestRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetCommentReplyInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetCommentReplyInSpaceRequest struct {
	ctx            context.Context
	ApiService     *SpacesApiService
	spaceId        string
	commentId      string
	commentReplyId string
	format         *string
}

// Output format for the content.
func (r SpacesApiGetCommentReplyInSpaceRequest) Format(format string) SpacesApiGetCommentReplyInSpaceRequest {
	r.format = &format
	return r
}

func (r SpacesApiGetCommentReplyInSpaceRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.GetCommentReplyInSpaceExecute(r)
}

/*
GetCommentReplyInSpace Get a comment reply in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiGetCommentReplyInSpaceRequest
*/
func (a *SpacesApiService) GetCommentReplyInSpace(ctx context.Context, spaceId string, commentId string, commentReplyId string) SpacesApiGetCommentReplyInSpaceRequest {
	return SpacesApiGetCommentReplyInSpaceRequest{
		ApiService:     a,
		ctx:            ctx,
		spaceId:        spaceId,
		commentId:      commentId,
		commentReplyId: commentReplyId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) GetCommentReplyInSpaceExecute(r SpacesApiGetCommentReplyInSpaceRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetCommentReplyInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetContentAnalyticsForSpaceByIdRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiGetContentAnalyticsForSpaceByIdRequest) Execute() (*AnalyticsContentPages, *http.Response, error) {
	return r.ApiService.GetContentAnalyticsForSpaceByIdExecute(r)
}

/*
GetContentAnalyticsForSpaceById Get content analytics for a given space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetContentAnalyticsForSpaceByIdRequest
*/
func (a *SpacesApiService) GetContentAnalyticsForSpaceById(ctx context.Context, spaceId string) SpacesApiGetContentAnalyticsForSpaceByIdRequest {
	return SpacesApiGetContentAnalyticsForSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return AnalyticsContentPages
func (a *SpacesApiService) GetContentAnalyticsForSpaceByIdExecute(r SpacesApiGetContentAnalyticsForSpaceByIdRequest) (*AnalyticsContentPages, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsContentPages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetContentAnalyticsForSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/insights/content"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetContributorsByChangeRequestIdRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
}

func (r SpacesApiGetContributorsByChangeRequestIdRequest) Execute() (*GetContributorsByChangeRequestId200Response, *http.Response, error) {
	return r.ApiService.GetContributorsByChangeRequestIdExecute(r)
}

/*
GetContributorsByChangeRequestId Get all contributors for the change request with the given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiGetContributorsByChangeRequestIdRequest
*/
func (a *SpacesApiService) GetContributorsByChangeRequestId(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiGetContributorsByChangeRequestIdRequest {
	return SpacesApiGetContributorsByChangeRequestIdRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return GetContributorsByChangeRequestId200Response
func (a *SpacesApiService) GetContributorsByChangeRequestIdExecute(r SpacesApiGetContributorsByChangeRequestIdRequest) (*GetContributorsByChangeRequestId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetContributorsByChangeRequestId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetContributorsByChangeRequestId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/contributors"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSpaceGitInfo404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetRequestedReviewersByChangeRequestIdRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	page            *string
	limit           *float32
}

// Identifier of the page results to fetch.
func (r SpacesApiGetRequestedReviewersByChangeRequestIdRequest) Page(page string) SpacesApiGetRequestedReviewersByChangeRequestIdRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiGetRequestedReviewersByChangeRequestIdRequest) Limit(limit float32) SpacesApiGetRequestedReviewersByChangeRequestIdRequest {
	r.limit = &limit
	return r
}

func (r SpacesApiGetRequestedReviewersByChangeRequestIdRequest) Execute() (*GetRequestedReviewersByChangeRequestId200Response, *http.Response, error) {
	return r.ApiService.GetRequestedReviewersByChangeRequestIdExecute(r)
}

/*
GetRequestedReviewersByChangeRequestId Get all requested reviewers for a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiGetRequestedReviewersByChangeRequestIdRequest
*/
func (a *SpacesApiService) GetRequestedReviewersByChangeRequestId(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiGetRequestedReviewersByChangeRequestIdRequest {
	return SpacesApiGetRequestedReviewersByChangeRequestIdRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return GetRequestedReviewersByChangeRequestId200Response
func (a *SpacesApiService) GetRequestedReviewersByChangeRequestIdExecute(r SpacesApiGetRequestedReviewersByChangeRequestIdRequest) (*GetRequestedReviewersByChangeRequestId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRequestedReviewersByChangeRequestId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetRequestedReviewersByChangeRequestId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/requested-reviewers"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetReviewsByChangeRequestIdRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	format          *string
	page            *string
	limit           *float32
}

// Output format for the content.
func (r SpacesApiGetReviewsByChangeRequestIdRequest) Format(format string) SpacesApiGetReviewsByChangeRequestIdRequest {
	r.format = &format
	return r
}

// Identifier of the page results to fetch.
func (r SpacesApiGetReviewsByChangeRequestIdRequest) Page(page string) SpacesApiGetReviewsByChangeRequestIdRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiGetReviewsByChangeRequestIdRequest) Limit(limit float32) SpacesApiGetReviewsByChangeRequestIdRequest {
	r.limit = &limit
	return r
}

func (r SpacesApiGetReviewsByChangeRequestIdRequest) Execute() (*GetReviewsByChangeRequestId200Response, *http.Response, error) {
	return r.ApiService.GetReviewsByChangeRequestIdExecute(r)
}

/*
GetReviewsByChangeRequestId Get all reviews for a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiGetReviewsByChangeRequestIdRequest
*/
func (a *SpacesApiService) GetReviewsByChangeRequestId(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiGetReviewsByChangeRequestIdRequest {
	return SpacesApiGetReviewsByChangeRequestIdRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return GetReviewsByChangeRequestId200Response
func (a *SpacesApiService) GetReviewsByChangeRequestIdExecute(r SpacesApiGetReviewsByChangeRequestIdRequest) (*GetReviewsByChangeRequestId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetReviewsByChangeRequestId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetReviewsByChangeRequestId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/reviews"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSpaceGitInfo404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSearchAnalyticsForSpaceByIdRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	period     *AnalyticsSearchPeriod
}

func (r SpacesApiGetSearchAnalyticsForSpaceByIdRequest) Period(period AnalyticsSearchPeriod) SpacesApiGetSearchAnalyticsForSpaceByIdRequest {
	r.period = &period
	return r
}

func (r SpacesApiGetSearchAnalyticsForSpaceByIdRequest) Execute() (*AnalyticsTopSearches, *http.Response, error) {
	return r.ApiService.GetSearchAnalyticsForSpaceByIdExecute(r)
}

/*
GetSearchAnalyticsForSpaceById Get an overview of the top search queries in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetSearchAnalyticsForSpaceByIdRequest
*/
func (a *SpacesApiService) GetSearchAnalyticsForSpaceById(ctx context.Context, spaceId string) SpacesApiGetSearchAnalyticsForSpaceByIdRequest {
	return SpacesApiGetSearchAnalyticsForSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return AnalyticsTopSearches
func (a *SpacesApiService) GetSearchAnalyticsForSpaceByIdExecute(r SpacesApiGetSearchAnalyticsForSpaceByIdRequest) (*AnalyticsTopSearches, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsTopSearches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSearchAnalyticsForSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/insights/search"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSpaceByIdRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiGetSpaceByIdRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.GetSpaceByIdExecute(r)
}

/*
GetSpaceById Get the details about a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetSpaceByIdRequest
*/
func (a *SpacesApiService) GetSpaceById(ctx context.Context, spaceId string) SpacesApiGetSpaceByIdRequest {
	return SpacesApiGetSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return Space
func (a *SpacesApiService) GetSpaceByIdExecute(r SpacesApiGetSpaceByIdRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSpaceCustomFieldsRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiGetSpaceCustomFieldsRequest) Execute() ([]CustomFieldValuesInner, *http.Response, error) {
	return r.ApiService.GetSpaceCustomFieldsExecute(r)
}

/*
GetSpaceCustomFields Get the values of the custom fields set on a space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetSpaceCustomFieldsRequest
*/
func (a *SpacesApiService) GetSpaceCustomFields(ctx context.Context, spaceId string) SpacesApiGetSpaceCustomFieldsRequest {
	return SpacesApiGetSpaceCustomFieldsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []CustomFieldValuesInner
func (a *SpacesApiService) GetSpaceCustomFieldsExecute(r SpacesApiGetSpaceCustomFieldsRequest) ([]CustomFieldValuesInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CustomFieldValuesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSpaceCustomFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/custom-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSpaceGitInfoRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiGetSpaceGitInfoRequest) Execute() (*GitSyncState, *http.Response, error) {
	return r.ApiService.GetSpaceGitInfoExecute(r)
}

/*
GetSpaceGitInfo Get metadata about the Git Sync provider currently set up on the space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetSpaceGitInfoRequest
*/
func (a *SpacesApiService) GetSpaceGitInfo(ctx context.Context, spaceId string) SpacesApiGetSpaceGitInfoRequest {
	return SpacesApiGetSpaceGitInfoRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return GitSyncState
func (a *SpacesApiService) GetSpaceGitInfoExecute(r SpacesApiGetSpaceGitInfoRequest) (*GitSyncState, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitSyncState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSpaceGitInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/git/info"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSpaceGitInfo404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSpacePublishingAuthByIdRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
}

func (r SpacesApiGetSpacePublishingAuthByIdRequest) Execute() (*ContentPublishingAuth, *http.Response, error) {
	return r.ApiService.GetSpacePublishingAuthByIdExecute(r)
}

/*
GetSpacePublishingAuthById Get the publishing authentication configuration for a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetSpacePublishingAuthByIdRequest
*/
func (a *SpacesApiService) GetSpacePublishingAuthById(ctx context.Context, spaceId string) SpacesApiGetSpacePublishingAuthByIdRequest {
	return SpacesApiGetSpacePublishingAuthByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ContentPublishingAuth
func (a *SpacesApiService) GetSpacePublishingAuthByIdExecute(r SpacesApiGetSpacePublishingAuthByIdRequest) (*ContentPublishingAuth, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ContentPublishingAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSpacePublishingAuthById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/publishing/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetSpacePublishingAuthById400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetSpaceRelationRequest struct {
	ctx           context.Context
	ApiService    *SpacesApiService
	spaceId       string
	targetSpaceId string
}

func (r SpacesApiGetSpaceRelationRequest) Execute() (*SpaceRelation, *http.Response, error) {
	return r.ApiService.GetSpaceRelationExecute(r)
}

/*
GetSpaceRelation Get the relation between 2 spaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param targetSpaceId The ID of the other space
	@return SpacesApiGetSpaceRelationRequest
*/
func (a *SpacesApiService) GetSpaceRelation(ctx context.Context, spaceId string, targetSpaceId string) SpacesApiGetSpaceRelationRequest {
	return SpacesApiGetSpaceRelationRequest{
		ApiService:    a,
		ctx:           ctx,
		spaceId:       spaceId,
		targetSpaceId: targetSpaceId,
	}
}

// Execute executes the request
//
//	@return SpaceRelation
func (a *SpacesApiService) GetSpaceRelationExecute(r SpacesApiGetSpaceRelationRequest) (*SpaceRelation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpaceRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetSpaceRelation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/relations/{targetSpaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetSpaceId"+"}", url.PathEscape(parameterValueToString(r.targetSpaceId, "targetSpaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSpaceGitInfo404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiGetTrafficAnalyticsForSpaceByIdRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	interval   *AnalyticsTrafficInterval
}

func (r SpacesApiGetTrafficAnalyticsForSpaceByIdRequest) Interval(interval AnalyticsTrafficInterval) SpacesApiGetTrafficAnalyticsForSpaceByIdRequest {
	r.interval = &interval
	return r
}

func (r SpacesApiGetTrafficAnalyticsForSpaceByIdRequest) Execute() (*AnalyticsTrafficPageViews, *http.Response, error) {
	return r.ApiService.GetTrafficAnalyticsForSpaceByIdExecute(r)
}

/*
GetTrafficAnalyticsForSpaceById Get traffic page views for a given space

Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiGetTrafficAnalyticsForSpaceByIdRequest
*/
func (a *SpacesApiService) GetTrafficAnalyticsForSpaceById(ctx context.Context, spaceId string) SpacesApiGetTrafficAnalyticsForSpaceByIdRequest {
	return SpacesApiGetTrafficAnalyticsForSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return AnalyticsTrafficPageViews
func (a *SpacesApiService) GetTrafficAnalyticsForSpaceByIdExecute(r SpacesApiGetTrafficAnalyticsForSpaceByIdRequest) (*AnalyticsTrafficPageViews, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsTrafficPageViews
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.GetTrafficAnalyticsForSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/insights/traffic"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiImportGitRepositoryRequest struct {
	ctx                        context.Context
	ApiService                 *SpacesApiService
	spaceId                    string
	requestImportGitRepository *RequestImportGitRepository
}

func (r SpacesApiImportGitRepositoryRequest) RequestImportGitRepository(requestImportGitRepository RequestImportGitRepository) SpacesApiImportGitRepositoryRequest {
	r.requestImportGitRepository = &requestImportGitRepository
	return r
}

func (r SpacesApiImportGitRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportGitRepositoryExecute(r)
}

/*
ImportGitRepository Import a Git repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiImportGitRepositoryRequest
*/
func (a *SpacesApiService) ImportGitRepository(ctx context.Context, spaceId string) SpacesApiImportGitRepositoryRequest {
	return SpacesApiImportGitRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *SpacesApiService) ImportGitRepositoryExecute(r SpacesApiImportGitRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ImportGitRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/git/import"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestImportGitRepository == nil {
		return nil, reportError("requestImportGitRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestImportGitRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiListChangeRequestsForSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	page       *string
	limit      *float32
	status     *ChangeRequestStatus
}

// Identifier of the page results to fetch.
func (r SpacesApiListChangeRequestsForSpaceRequest) Page(page string) SpacesApiListChangeRequestsForSpaceRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListChangeRequestsForSpaceRequest) Limit(limit float32) SpacesApiListChangeRequestsForSpaceRequest {
	r.limit = &limit
	return r
}

// If defined, only change requests matching this status will be returned
func (r SpacesApiListChangeRequestsForSpaceRequest) Status(status ChangeRequestStatus) SpacesApiListChangeRequestsForSpaceRequest {
	r.status = &status
	return r
}

func (r SpacesApiListChangeRequestsForSpaceRequest) Execute() (*ListChangeRequestsForSpace200Response, *http.Response, error) {
	return r.ApiService.ListChangeRequestsForSpaceExecute(r)
}

/*
ListChangeRequestsForSpace List change requests for a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiListChangeRequestsForSpaceRequest
*/
func (a *SpacesApiService) ListChangeRequestsForSpace(ctx context.Context, spaceId string) SpacesApiListChangeRequestsForSpaceRequest {
	return SpacesApiListChangeRequestsForSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ListChangeRequestsForSpace200Response
func (a *SpacesApiService) ListChangeRequestsForSpaceExecute(r SpacesApiListChangeRequestsForSpaceRequest) (*ListChangeRequestsForSpace200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListChangeRequestsForSpace200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListChangeRequestsForSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListCommentRepliesInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	commentId       string
	page            *string
	limit           *float32
	format          *string
}

// Identifier of the page results to fetch.
func (r SpacesApiListCommentRepliesInChangeRequestRequest) Page(page string) SpacesApiListCommentRepliesInChangeRequestRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListCommentRepliesInChangeRequestRequest) Limit(limit float32) SpacesApiListCommentRepliesInChangeRequestRequest {
	r.limit = &limit
	return r
}

// Output format for the content.
func (r SpacesApiListCommentRepliesInChangeRequestRequest) Format(format string) SpacesApiListCommentRepliesInChangeRequestRequest {
	r.format = &format
	return r
}

func (r SpacesApiListCommentRepliesInChangeRequestRequest) Execute() (*ListCommentRepliesInChangeRequest200Response, *http.Response, error) {
	return r.ApiService.ListCommentRepliesInChangeRequestExecute(r)
}

/*
ListCommentRepliesInChangeRequest List all the replies to a comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@return SpacesApiListCommentRepliesInChangeRequestRequest
*/
func (a *SpacesApiService) ListCommentRepliesInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string) SpacesApiListCommentRepliesInChangeRequestRequest {
	return SpacesApiListCommentRepliesInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
	}
}

// Execute executes the request
//
//	@return ListCommentRepliesInChangeRequest200Response
func (a *SpacesApiService) ListCommentRepliesInChangeRequestExecute(r SpacesApiListCommentRepliesInChangeRequestRequest) (*ListCommentRepliesInChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCommentRepliesInChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListCommentRepliesInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListCommentRepliesInSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	commentId  string
	page       *string
	limit      *float32
	format     *string
}

// Identifier of the page results to fetch.
func (r SpacesApiListCommentRepliesInSpaceRequest) Page(page string) SpacesApiListCommentRepliesInSpaceRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListCommentRepliesInSpaceRequest) Limit(limit float32) SpacesApiListCommentRepliesInSpaceRequest {
	r.limit = &limit
	return r
}

// Output format for the content.
func (r SpacesApiListCommentRepliesInSpaceRequest) Format(format string) SpacesApiListCommentRepliesInSpaceRequest {
	r.format = &format
	return r
}

func (r SpacesApiListCommentRepliesInSpaceRequest) Execute() (*ListCommentRepliesInChangeRequest200Response, *http.Response, error) {
	return r.ApiService.ListCommentRepliesInSpaceExecute(r)
}

/*
ListCommentRepliesInSpace List all the replies to a comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@return SpacesApiListCommentRepliesInSpaceRequest
*/
func (a *SpacesApiService) ListCommentRepliesInSpace(ctx context.Context, spaceId string, commentId string) SpacesApiListCommentRepliesInSpaceRequest {
	return SpacesApiListCommentRepliesInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return ListCommentRepliesInChangeRequest200Response
func (a *SpacesApiService) ListCommentRepliesInSpaceExecute(r SpacesApiListCommentRepliesInSpaceRequest) (*ListCommentRepliesInChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCommentRepliesInChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListCommentRepliesInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListCommentsInChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
	page            *string
	limit           *float32
	format          *string
	status          *string
}

// Identifier of the page results to fetch.
func (r SpacesApiListCommentsInChangeRequestRequest) Page(page string) SpacesApiListCommentsInChangeRequestRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListCommentsInChangeRequestRequest) Limit(limit float32) SpacesApiListCommentsInChangeRequestRequest {
	r.limit = &limit
	return r
}

// Output format for the content.
func (r SpacesApiListCommentsInChangeRequestRequest) Format(format string) SpacesApiListCommentsInChangeRequestRequest {
	r.format = &format
	return r
}

// When provided, only comments with the given status are returned. Only \&quot;all\&quot; is supported for now.
func (r SpacesApiListCommentsInChangeRequestRequest) Status(status string) SpacesApiListCommentsInChangeRequestRequest {
	r.status = &status
	return r
}

func (r SpacesApiListCommentsInChangeRequestRequest) Execute() (*ListCommentsInChangeRequest200Response, *http.Response, error) {
	return r.ApiService.ListCommentsInChangeRequestExecute(r)
}

/*
ListCommentsInChangeRequest List all the comments in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiListCommentsInChangeRequestRequest
*/
func (a *SpacesApiService) ListCommentsInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiListCommentsInChangeRequestRequest {
	return SpacesApiListCommentsInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return ListCommentsInChangeRequest200Response
func (a *SpacesApiService) ListCommentsInChangeRequestExecute(r SpacesApiListCommentsInChangeRequestRequest) (*ListCommentsInChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCommentsInChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListCommentsInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListCommentsInSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	page       *string
	limit      *float32
	status     *string
	format     *string
}

// Identifier of the page results to fetch.
func (r SpacesApiListCommentsInSpaceRequest) Page(page string) SpacesApiListCommentsInSpaceRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListCommentsInSpaceRequest) Limit(limit float32) SpacesApiListCommentsInSpaceRequest {
	r.limit = &limit
	return r
}

// When provided, only comments with the given status are returned. Only \&quot;all\&quot; is supported for now.
func (r SpacesApiListCommentsInSpaceRequest) Status(status string) SpacesApiListCommentsInSpaceRequest {
	r.status = &status
	return r
}

// Output format for the content.
func (r SpacesApiListCommentsInSpaceRequest) Format(format string) SpacesApiListCommentsInSpaceRequest {
	r.format = &format
	return r
}

func (r SpacesApiListCommentsInSpaceRequest) Execute() (*ListCommentsInChangeRequest200Response, *http.Response, error) {
	return r.ApiService.ListCommentsInSpaceExecute(r)
}

/*
ListCommentsInSpace List all the comments in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiListCommentsInSpaceRequest
*/
func (a *SpacesApiService) ListCommentsInSpace(ctx context.Context, spaceId string) SpacesApiListCommentsInSpaceRequest {
	return SpacesApiListCommentsInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ListCommentsInChangeRequest200Response
func (a *SpacesApiService) ListCommentsInSpaceExecute(r SpacesApiListCommentsInSpaceRequest) (*ListCommentsInChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCommentsInChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListCommentsInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListPermissionsAggregateInCollectionRequest struct {
	ctx          context.Context
	ApiService   *SpacesApiService
	collectionId string
	page         *string
	limit        *float32
	role         *MemberRole
}

// Identifier of the page results to fetch.
func (r SpacesApiListPermissionsAggregateInCollectionRequest) Page(page string) SpacesApiListPermissionsAggregateInCollectionRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListPermissionsAggregateInCollectionRequest) Limit(limit float32) SpacesApiListPermissionsAggregateInCollectionRequest {
	r.limit = &limit
	return r
}

// If defined, only members with this role will be returned.
func (r SpacesApiListPermissionsAggregateInCollectionRequest) Role(role MemberRole) SpacesApiListPermissionsAggregateInCollectionRequest {
	r.role = &role
	return r
}

func (r SpacesApiListPermissionsAggregateInCollectionRequest) Execute() (*ListPermissionsAggregateInSpace200Response, *http.Response, error) {
	return r.ApiService.ListPermissionsAggregateInCollectionExecute(r)
}

/*
ListPermissionsAggregateInCollection List permissions for all users in a collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId The unique id of the collection
	@return SpacesApiListPermissionsAggregateInCollectionRequest
*/
func (a *SpacesApiService) ListPermissionsAggregateInCollection(ctx context.Context, collectionId string) SpacesApiListPermissionsAggregateInCollectionRequest {
	return SpacesApiListPermissionsAggregateInCollectionRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//
//	@return ListPermissionsAggregateInSpace200Response
func (a *SpacesApiService) ListPermissionsAggregateInCollectionExecute(r SpacesApiListPermissionsAggregateInCollectionRequest) (*ListPermissionsAggregateInSpace200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPermissionsAggregateInSpace200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListPermissionsAggregateInCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/collections/{collectionId}/permissions/aggregate"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListPermissionsAggregateInSpaceRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	page       *string
	limit      *float32
	role       *MemberRole
}

// Identifier of the page results to fetch.
func (r SpacesApiListPermissionsAggregateInSpaceRequest) Page(page string) SpacesApiListPermissionsAggregateInSpaceRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListPermissionsAggregateInSpaceRequest) Limit(limit float32) SpacesApiListPermissionsAggregateInSpaceRequest {
	r.limit = &limit
	return r
}

// If defined, only members with this role will be returned.
func (r SpacesApiListPermissionsAggregateInSpaceRequest) Role(role MemberRole) SpacesApiListPermissionsAggregateInSpaceRequest {
	r.role = &role
	return r
}

func (r SpacesApiListPermissionsAggregateInSpaceRequest) Execute() (*ListPermissionsAggregateInSpace200Response, *http.Response, error) {
	return r.ApiService.ListPermissionsAggregateInSpaceExecute(r)
}

/*
ListPermissionsAggregateInSpace List permissions for all users in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiListPermissionsAggregateInSpaceRequest
*/
func (a *SpacesApiService) ListPermissionsAggregateInSpace(ctx context.Context, spaceId string) SpacesApiListPermissionsAggregateInSpaceRequest {
	return SpacesApiListPermissionsAggregateInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ListPermissionsAggregateInSpace200Response
func (a *SpacesApiService) ListPermissionsAggregateInSpaceExecute(r SpacesApiListPermissionsAggregateInSpaceRequest) (*ListPermissionsAggregateInSpace200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPermissionsAggregateInSpace200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListPermissionsAggregateInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/permissions/aggregate"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListSpaceRelationsRequest struct {
	ctx        context.Context
	ApiService *SpacesApiService
	spaceId    string
	page       *string
	limit      *float32
}

// Identifier of the page results to fetch.
func (r SpacesApiListSpaceRelationsRequest) Page(page string) SpacesApiListSpaceRelationsRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListSpaceRelationsRequest) Limit(limit float32) SpacesApiListSpaceRelationsRequest {
	r.limit = &limit
	return r
}

func (r SpacesApiListSpaceRelationsRequest) Execute() (*ListSpaceRelations200Response, *http.Response, error) {
	return r.ApiService.ListSpaceRelationsExecute(r)
}

/*
ListSpaceRelations List all relations for a space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiListSpaceRelationsRequest
*/
func (a *SpacesApiService) ListSpaceRelations(ctx context.Context, spaceId string) SpacesApiListSpaceRelationsRequest {
	return SpacesApiListSpaceRelationsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ListSpaceRelations200Response
func (a *SpacesApiService) ListSpaceRelationsExecute(r SpacesApiListSpaceRelationsRequest) (*ListSpaceRelations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSpaceRelations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListSpaceRelations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/relations"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListSpaceRelationsInOrganizationRequest struct {
	ctx            context.Context
	ApiService     *SpacesApiService
	organizationId string
	page           *string
	limit          *float32
}

// Identifier of the page results to fetch.
func (r SpacesApiListSpaceRelationsInOrganizationRequest) Page(page string) SpacesApiListSpaceRelationsInOrganizationRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListSpaceRelationsInOrganizationRequest) Limit(limit float32) SpacesApiListSpaceRelationsInOrganizationRequest {
	r.limit = &limit
	return r
}

func (r SpacesApiListSpaceRelationsInOrganizationRequest) Execute() (*ListSpaceRelationsInOrganization200Response, *http.Response, error) {
	return r.ApiService.ListSpaceRelationsInOrganizationExecute(r)
}

/*
ListSpaceRelationsInOrganization List all relations between spaces in an organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The unique id of the organization
	@return SpacesApiListSpaceRelationsInOrganizationRequest
*/
func (a *SpacesApiService) ListSpaceRelationsInOrganization(ctx context.Context, organizationId string) SpacesApiListSpaceRelationsInOrganizationRequest {
	return SpacesApiListSpaceRelationsInOrganizationRequest{
		ApiService:     a,
		ctx:            ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//
//	@return ListSpaceRelationsInOrganization200Response
func (a *SpacesApiService) ListSpaceRelationsInOrganizationExecute(r SpacesApiListSpaceRelationsInOrganizationRequest) (*ListSpaceRelationsInOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSpaceRelationsInOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListSpaceRelationsInOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{organizationId}/space-relations"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiListSpacesForOrganizationMemberRequest struct {
	ctx            context.Context
	ApiService     *SpacesApiService
	organizationId string
	userId         string
	page           *string
	limit          *float32
}

// Identifier of the page results to fetch.
func (r SpacesApiListSpacesForOrganizationMemberRequest) Page(page string) SpacesApiListSpacesForOrganizationMemberRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r SpacesApiListSpacesForOrganizationMemberRequest) Limit(limit float32) SpacesApiListSpacesForOrganizationMemberRequest {
	r.limit = &limit
	return r
}

func (r SpacesApiListSpacesForOrganizationMemberRequest) Execute() (*ListSpacesForOrganizationMember200Response, *http.Response, error) {
	return r.ApiService.ListSpacesForOrganizationMemberExecute(r)
}

/*
ListSpacesForOrganizationMember List permissions accross all spaces for a member of an organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The unique id of the organization
	@param userId The unique ID of the User
	@return SpacesApiListSpacesForOrganizationMemberRequest
*/
func (a *SpacesApiService) ListSpacesForOrganizationMember(ctx context.Context, organizationId string, userId string) SpacesApiListSpacesForOrganizationMemberRequest {
	return SpacesApiListSpacesForOrganizationMemberRequest{
		ApiService:     a,
		ctx:            ctx,
		organizationId: organizationId,
		userId:         userId,
	}
}

// Execute executes the request
//
//	@return ListSpacesForOrganizationMember200Response
func (a *SpacesApiService) ListSpacesForOrganizationMemberExecute(r SpacesApiListSpacesForOrganizationMemberRequest) (*ListSpacesForOrganizationMember200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSpacesForOrganizationMember200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.ListSpacesForOrganizationMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{organizationId}/members/{userId}/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiMergeChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
}

func (r SpacesApiMergeChangeRequestRequest) Execute() (*MergeChangeRequest200Response, *http.Response, error) {
	return r.ApiService.MergeChangeRequestExecute(r)
}

/*
MergeChangeRequest Merge a change request in the primary content of a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiMergeChangeRequestRequest
*/
func (a *SpacesApiService) MergeChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiMergeChangeRequestRequest {
	return SpacesApiMergeChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return MergeChangeRequest200Response
func (a *SpacesApiService) MergeChangeRequestExecute(r SpacesApiMergeChangeRequestRequest) (*MergeChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MergeChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.MergeChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiPostCommentInChangeRequestRequest struct {
	ctx               context.Context
	ApiService        *SpacesApiService
	spaceId           string
	changeRequestId   GetChangeRequestByIdChangeRequestIdParameter
	postCommentSchema *PostCommentSchema
}

func (r SpacesApiPostCommentInChangeRequestRequest) PostCommentSchema(postCommentSchema PostCommentSchema) SpacesApiPostCommentInChangeRequestRequest {
	r.postCommentSchema = &postCommentSchema
	return r
}

func (r SpacesApiPostCommentInChangeRequestRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.PostCommentInChangeRequestExecute(r)
}

/*
PostCommentInChangeRequest Post a new comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiPostCommentInChangeRequestRequest
*/
func (a *SpacesApiService) PostCommentInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiPostCommentInChangeRequestRequest {
	return SpacesApiPostCommentInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) PostCommentInChangeRequestExecute(r SpacesApiPostCommentInChangeRequestRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.PostCommentInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postCommentSchema == nil {
		return localVarReturnValue, nil, reportError("postCommentSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postCommentSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiPostCommentInSpaceRequest struct {
	ctx               context.Context
	ApiService        *SpacesApiService
	spaceId           string
	postCommentSchema *PostCommentSchema
}

func (r SpacesApiPostCommentInSpaceRequest) PostCommentSchema(postCommentSchema PostCommentSchema) SpacesApiPostCommentInSpaceRequest {
	r.postCommentSchema = &postCommentSchema
	return r
}

func (r SpacesApiPostCommentInSpaceRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.PostCommentInSpaceExecute(r)
}

/*
PostCommentInSpace Post a new comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiPostCommentInSpaceRequest
*/
func (a *SpacesApiService) PostCommentInSpace(ctx context.Context, spaceId string) SpacesApiPostCommentInSpaceRequest {
	return SpacesApiPostCommentInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) PostCommentInSpaceExecute(r SpacesApiPostCommentInSpaceRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.PostCommentInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postCommentSchema == nil {
		return localVarReturnValue, nil, reportError("postCommentSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postCommentSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiPostCommentReplyInChangeRequestRequest struct {
	ctx                    context.Context
	ApiService             *SpacesApiService
	spaceId                string
	changeRequestId        GetChangeRequestByIdChangeRequestIdParameter
	commentId              string
	postCommentReplySchema *PostCommentReplySchema
	format                 *string
}

func (r SpacesApiPostCommentReplyInChangeRequestRequest) PostCommentReplySchema(postCommentReplySchema PostCommentReplySchema) SpacesApiPostCommentReplyInChangeRequestRequest {
	r.postCommentReplySchema = &postCommentReplySchema
	return r
}

// Output format for the content.
func (r SpacesApiPostCommentReplyInChangeRequestRequest) Format(format string) SpacesApiPostCommentReplyInChangeRequestRequest {
	r.format = &format
	return r
}

func (r SpacesApiPostCommentReplyInChangeRequestRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.PostCommentReplyInChangeRequestExecute(r)
}

/*
PostCommentReplyInChangeRequest Post a new reply to a comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@return SpacesApiPostCommentReplyInChangeRequestRequest
*/
func (a *SpacesApiService) PostCommentReplyInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string) SpacesApiPostCommentReplyInChangeRequestRequest {
	return SpacesApiPostCommentReplyInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) PostCommentReplyInChangeRequestExecute(r SpacesApiPostCommentReplyInChangeRequestRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.PostCommentReplyInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postCommentReplySchema == nil {
		return localVarReturnValue, nil, reportError("postCommentReplySchema is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postCommentReplySchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiPostCommentReplyInSpaceRequest struct {
	ctx                    context.Context
	ApiService             *SpacesApiService
	spaceId                string
	commentId              string
	postCommentReplySchema *PostCommentReplySchema
}

func (r SpacesApiPostCommentReplyInSpaceRequest) PostCommentReplySchema(postCommentReplySchema PostCommentReplySchema) SpacesApiPostCommentReplyInSpaceRequest {
	r.postCommentReplySchema = &postCommentReplySchema
	return r
}

func (r SpacesApiPostCommentReplyInSpaceRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.PostCommentReplyInSpaceExecute(r)
}

/*
PostCommentReplyInSpace Post a new reply to a comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@return SpacesApiPostCommentReplyInSpaceRequest
*/
func (a *SpacesApiService) PostCommentReplyInSpace(ctx context.Context, spaceId string, commentId string) SpacesApiPostCommentReplyInSpaceRequest {
	return SpacesApiPostCommentReplyInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) PostCommentReplyInSpaceExecute(r SpacesApiPostCommentReplyInSpaceRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.PostCommentReplyInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postCommentReplySchema == nil {
		return localVarReturnValue, nil, reportError("postCommentReplySchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postCommentReplySchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiRequestReviewersForChangeRequestRequest struct {
	ctx                                     context.Context
	ApiService                              *SpacesApiService
	spaceId                                 string
	changeRequestId                         GetChangeRequestByIdChangeRequestIdParameter
	requestReviewersForChangeRequestRequest *RequestReviewersForChangeRequestRequest
}

func (r SpacesApiRequestReviewersForChangeRequestRequest) RequestReviewersForChangeRequestRequest(requestReviewersForChangeRequestRequest RequestReviewersForChangeRequestRequest) SpacesApiRequestReviewersForChangeRequestRequest {
	r.requestReviewersForChangeRequestRequest = &requestReviewersForChangeRequestRequest
	return r
}

func (r SpacesApiRequestReviewersForChangeRequestRequest) Execute() (*RequestReviewersForChangeRequest200Response, *http.Response, error) {
	return r.ApiService.RequestReviewersForChangeRequestExecute(r)
}

/*
RequestReviewersForChangeRequest Request reviewers on a change request. Note that requesting a review from teams is not yet supported.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiRequestReviewersForChangeRequestRequest
*/
func (a *SpacesApiService) RequestReviewersForChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiRequestReviewersForChangeRequestRequest {
	return SpacesApiRequestReviewersForChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return RequestReviewersForChangeRequest200Response
func (a *SpacesApiService) RequestReviewersForChangeRequestExecute(r SpacesApiRequestReviewersForChangeRequestRequest) (*RequestReviewersForChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RequestReviewersForChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.RequestReviewersForChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/requested-reviewers"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestReviewersForChangeRequestRequest == nil {
		return localVarReturnValue, nil, reportError("requestReviewersForChangeRequestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestReviewersForChangeRequestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiSubmitChangeRequestReviewRequest struct {
	ctx                              context.Context
	ApiService                       *SpacesApiService
	spaceId                          string
	changeRequestId                  GetChangeRequestByIdChangeRequestIdParameter
	submitChangeRequestReviewRequest *SubmitChangeRequestReviewRequest
}

func (r SpacesApiSubmitChangeRequestReviewRequest) SubmitChangeRequestReviewRequest(submitChangeRequestReviewRequest SubmitChangeRequestReviewRequest) SpacesApiSubmitChangeRequestReviewRequest {
	r.submitChangeRequestReviewRequest = &submitChangeRequestReviewRequest
	return r
}

func (r SpacesApiSubmitChangeRequestReviewRequest) Execute() (*ChangeRequestReview, *http.Response, error) {
	return r.ApiService.SubmitChangeRequestReviewExecute(r)
}

/*
SubmitChangeRequestReview Submit a review for a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiSubmitChangeRequestReviewRequest
*/
func (a *SpacesApiService) SubmitChangeRequestReview(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiSubmitChangeRequestReviewRequest {
	return SpacesApiSubmitChangeRequestReviewRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return ChangeRequestReview
func (a *SpacesApiService) SubmitChangeRequestReviewExecute(r SpacesApiSubmitChangeRequestReviewRequest) (*ChangeRequestReview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChangeRequestReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.SubmitChangeRequestReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/reviews"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitChangeRequestReviewRequest == nil {
		return localVarReturnValue, nil, reportError("submitChangeRequestReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitChangeRequestReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiTrackViewInSpaceByIdRequest struct {
	ctx                       context.Context
	ApiService                *SpacesApiService
	spaceId                   string
	requestSpaceTrackPageView *RequestSpaceTrackPageView
}

func (r SpacesApiTrackViewInSpaceByIdRequest) RequestSpaceTrackPageView(requestSpaceTrackPageView RequestSpaceTrackPageView) SpacesApiTrackViewInSpaceByIdRequest {
	r.requestSpaceTrackPageView = &requestSpaceTrackPageView
	return r
}

func (r SpacesApiTrackViewInSpaceByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TrackViewInSpaceByIdExecute(r)
}

/*
TrackViewInSpaceById Method for TrackViewInSpaceById

Track a page view in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiTrackViewInSpaceByIdRequest
*/
func (a *SpacesApiService) TrackViewInSpaceById(ctx context.Context, spaceId string) SpacesApiTrackViewInSpaceByIdRequest {
	return SpacesApiTrackViewInSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *SpacesApiService) TrackViewInSpaceByIdExecute(r SpacesApiTrackViewInSpaceByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.TrackViewInSpaceById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/insights/track_view"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestSpaceTrackPageView == nil {
		return nil, reportError("requestSpaceTrackPageView is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestSpaceTrackPageView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiUpdateChangeRequestRequest struct {
	ctx             context.Context
	ApiService      *SpacesApiService
	spaceId         string
	changeRequestId GetChangeRequestByIdChangeRequestIdParameter
}

func (r SpacesApiUpdateChangeRequestRequest) Execute() (*UpdateChangeRequest200Response, *http.Response, error) {
	return r.ApiService.UpdateChangeRequestExecute(r)
}

/*
UpdateChangeRequest Update a change-request with changes from primary content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@return SpacesApiUpdateChangeRequestRequest
*/
func (a *SpacesApiService) UpdateChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter) SpacesApiUpdateChangeRequestRequest {
	return SpacesApiUpdateChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
	}
}

// Execute executes the request
//
//	@return UpdateChangeRequest200Response
func (a *SpacesApiService) UpdateChangeRequestExecute(r SpacesApiUpdateChangeRequestRequest) (*UpdateChangeRequest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateChangeRequest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateCommentInChangeRequestRequest struct {
	ctx                 context.Context
	ApiService          *SpacesApiService
	spaceId             string
	changeRequestId     GetChangeRequestByIdChangeRequestIdParameter
	commentId           string
	updateCommentSchema *UpdateCommentSchema
}

func (r SpacesApiUpdateCommentInChangeRequestRequest) UpdateCommentSchema(updateCommentSchema UpdateCommentSchema) SpacesApiUpdateCommentInChangeRequestRequest {
	r.updateCommentSchema = &updateCommentSchema
	return r
}

func (r SpacesApiUpdateCommentInChangeRequestRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.UpdateCommentInChangeRequestExecute(r)
}

/*
UpdateCommentInChangeRequest Update a comment in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@return SpacesApiUpdateCommentInChangeRequestRequest
*/
func (a *SpacesApiService) UpdateCommentInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string) SpacesApiUpdateCommentInChangeRequestRequest {
	return SpacesApiUpdateCommentInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) UpdateCommentInChangeRequestExecute(r SpacesApiUpdateCommentInChangeRequestRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateCommentInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCommentSchema == nil {
		return localVarReturnValue, nil, reportError("updateCommentSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCommentSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateCommentInSpaceRequest struct {
	ctx                 context.Context
	ApiService          *SpacesApiService
	spaceId             string
	commentId           string
	updateCommentSchema *UpdateCommentSchema
}

func (r SpacesApiUpdateCommentInSpaceRequest) UpdateCommentSchema(updateCommentSchema UpdateCommentSchema) SpacesApiUpdateCommentInSpaceRequest {
	r.updateCommentSchema = &updateCommentSchema
	return r
}

func (r SpacesApiUpdateCommentInSpaceRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.UpdateCommentInSpaceExecute(r)
}

/*
UpdateCommentInSpace Update a comment in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@return SpacesApiUpdateCommentInSpaceRequest
*/
func (a *SpacesApiService) UpdateCommentInSpace(ctx context.Context, spaceId string, commentId string) SpacesApiUpdateCommentInSpaceRequest {
	return SpacesApiUpdateCommentInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return Comment
func (a *SpacesApiService) UpdateCommentInSpaceExecute(r SpacesApiUpdateCommentInSpaceRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateCommentInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCommentSchema == nil {
		return localVarReturnValue, nil, reportError("updateCommentSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCommentSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateCommentReplyInChangeRequestRequest struct {
	ctx                 context.Context
	ApiService          *SpacesApiService
	spaceId             string
	changeRequestId     GetChangeRequestByIdChangeRequestIdParameter
	commentId           string
	commentReplyId      string
	updateCommentSchema *UpdateCommentSchema
}

func (r SpacesApiUpdateCommentReplyInChangeRequestRequest) UpdateCommentSchema(updateCommentSchema UpdateCommentSchema) SpacesApiUpdateCommentReplyInChangeRequestRequest {
	r.updateCommentSchema = &updateCommentSchema
	return r
}

func (r SpacesApiUpdateCommentReplyInChangeRequestRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.UpdateCommentReplyInChangeRequestExecute(r)
}

/*
UpdateCommentReplyInChangeRequest Update a comment reply in a change request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param changeRequestId The unique ID of the change request or its number identifier in the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiUpdateCommentReplyInChangeRequestRequest
*/
func (a *SpacesApiService) UpdateCommentReplyInChangeRequest(ctx context.Context, spaceId string, changeRequestId GetChangeRequestByIdChangeRequestIdParameter, commentId string, commentReplyId string) SpacesApiUpdateCommentReplyInChangeRequestRequest {
	return SpacesApiUpdateCommentReplyInChangeRequestRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		changeRequestId: changeRequestId,
		commentId:       commentId,
		commentReplyId:  commentReplyId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) UpdateCommentReplyInChangeRequestExecute(r SpacesApiUpdateCommentReplyInChangeRequestRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateCommentReplyInChangeRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changeRequestId"+"}", url.PathEscape(parameterValueToString(r.changeRequestId, "changeRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCommentSchema == nil {
		return localVarReturnValue, nil, reportError("updateCommentSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCommentSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateCommentReplyInSpaceRequest struct {
	ctx                      context.Context
	ApiService               *SpacesApiService
	spaceId                  string
	commentId                string
	commentReplyId           string
	updateCommentReplySchema *UpdateCommentReplySchema
}

func (r SpacesApiUpdateCommentReplyInSpaceRequest) UpdateCommentReplySchema(updateCommentReplySchema UpdateCommentReplySchema) SpacesApiUpdateCommentReplyInSpaceRequest {
	r.updateCommentReplySchema = &updateCommentReplySchema
	return r
}

func (r SpacesApiUpdateCommentReplyInSpaceRequest) Execute() (*CommentReply, *http.Response, error) {
	return r.ApiService.UpdateCommentReplyInSpaceExecute(r)
}

/*
UpdateCommentReplyInSpace Update a comment reply in a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@param commentId The unique id of the comment
	@param commentReplyId The unique id of the comment reply
	@return SpacesApiUpdateCommentReplyInSpaceRequest
*/
func (a *SpacesApiService) UpdateCommentReplyInSpace(ctx context.Context, spaceId string, commentId string, commentReplyId string) SpacesApiUpdateCommentReplyInSpaceRequest {
	return SpacesApiUpdateCommentReplyInSpaceRequest{
		ApiService:     a,
		ctx:            ctx,
		spaceId:        spaceId,
		commentId:      commentId,
		commentReplyId: commentReplyId,
	}
}

// Execute executes the request
//
//	@return CommentReply
func (a *SpacesApiService) UpdateCommentReplyInSpaceExecute(r SpacesApiUpdateCommentReplyInSpaceRequest) (*CommentReply, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CommentReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateCommentReplyInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentReplyId"+"}", url.PathEscape(parameterValueToString(r.commentReplyId, "commentReplyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCommentReplySchema == nil {
		return localVarReturnValue, nil, reportError("updateCommentReplySchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCommentReplySchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateSpaceByIdRequest struct {
	ctx                    context.Context
	ApiService             *SpacesApiService
	spaceId                string
	updateSpaceByIdRequest *UpdateSpaceByIdRequest
}

func (r SpacesApiUpdateSpaceByIdRequest) UpdateSpaceByIdRequest(updateSpaceByIdRequest UpdateSpaceByIdRequest) SpacesApiUpdateSpaceByIdRequest {
	r.updateSpaceByIdRequest = &updateSpaceByIdRequest
	return r
}

func (r SpacesApiUpdateSpaceByIdRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.UpdateSpaceByIdExecute(r)
}

/*
UpdateSpaceById Update the details of a space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiUpdateSpaceByIdRequest
*/
func (a *SpacesApiService) UpdateSpaceById(ctx context.Context, spaceId string) SpacesApiUpdateSpaceByIdRequest {
	return SpacesApiUpdateSpaceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return Space
func (a *SpacesApiService) UpdateSpaceByIdExecute(r SpacesApiUpdateSpaceByIdRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSpaceByIdRequest == nil {
		return localVarReturnValue, nil, reportError("updateSpaceByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSpaceByIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SpacesApiUpdateSpaceCustomFieldsRequest struct {
	ctx                     context.Context
	ApiService              *SpacesApiService
	spaceId                 string
	updateCustomFieldValues *UpdateCustomFieldValues
}

func (r SpacesApiUpdateSpaceCustomFieldsRequest) UpdateCustomFieldValues(updateCustomFieldValues UpdateCustomFieldValues) SpacesApiUpdateSpaceCustomFieldsRequest {
	r.updateCustomFieldValues = &updateCustomFieldValues
	return r
}

func (r SpacesApiUpdateSpaceCustomFieldsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSpaceCustomFieldsExecute(r)
}

/*
UpdateSpaceCustomFields Update the custom fields in a space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiUpdateSpaceCustomFieldsRequest
*/
func (a *SpacesApiService) UpdateSpaceCustomFields(ctx context.Context, spaceId string) SpacesApiUpdateSpaceCustomFieldsRequest {
	return SpacesApiUpdateSpaceCustomFieldsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *SpacesApiService) UpdateSpaceCustomFieldsExecute(r SpacesApiUpdateSpaceCustomFieldsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateSpaceCustomFields")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/custom-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCustomFieldValues == nil {
		return nil, reportError("updateCustomFieldValues is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCustomFieldValues
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SpacesApiUpdateSpacePublishingAuthByIdRequest struct {
	ctx                                context.Context
	ApiService                         *SpacesApiService
	spaceId                            string
	requestUpdateContentPublishingAuth *RequestUpdateContentPublishingAuth
}

func (r SpacesApiUpdateSpacePublishingAuthByIdRequest) RequestUpdateContentPublishingAuth(requestUpdateContentPublishingAuth RequestUpdateContentPublishingAuth) SpacesApiUpdateSpacePublishingAuthByIdRequest {
	r.requestUpdateContentPublishingAuth = &requestUpdateContentPublishingAuth
	return r
}

func (r SpacesApiUpdateSpacePublishingAuthByIdRequest) Execute() (*ContentPublishingAuth, *http.Response, error) {
	return r.ApiService.UpdateSpacePublishingAuthByIdExecute(r)
}

/*
UpdateSpacePublishingAuthById Update the publishing authentication configuration for a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return SpacesApiUpdateSpacePublishingAuthByIdRequest
*/
func (a *SpacesApiService) UpdateSpacePublishingAuthById(ctx context.Context, spaceId string) SpacesApiUpdateSpacePublishingAuthByIdRequest {
	return SpacesApiUpdateSpacePublishingAuthByIdRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ContentPublishingAuth
func (a *SpacesApiService) UpdateSpacePublishingAuthByIdExecute(r SpacesApiUpdateSpacePublishingAuthByIdRequest) (*ContentPublishingAuth, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ContentPublishingAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesApiService.UpdateSpacePublishingAuthById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/publishing/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestUpdateContentPublishingAuth == nil {
		return localVarReturnValue, nil, reportError("requestUpdateContentPublishingAuth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestUpdateContentPublishingAuth
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetSpacePublishingAuthById400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
