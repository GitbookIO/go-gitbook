/*
GitBook API

The GitBook API

API version: 0.0.1-beta
Contact: support@gitbook.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gitbook

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// IntegrationsApiService IntegrationsApi service
type IntegrationsApiService service

type IntegrationsApiCreateIntegrationInstallationTokenRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	installationId  string
}

func (r IntegrationsApiCreateIntegrationInstallationTokenRequest) Execute() (*APITemporaryToken, *http.Response, error) {
	return r.ApiService.CreateIntegrationInstallationTokenExecute(r)
}

/*
CreateIntegrationInstallationToken Create an integration installation API token

Creates a temporary API token of an integration's installation that has access to the installation and it's scopes. You must be authenticated as the integration to obtain this token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiCreateIntegrationInstallationTokenRequest
*/
func (a *IntegrationsApiService) CreateIntegrationInstallationToken(ctx context.Context, integrationName string, installationId string) IntegrationsApiCreateIntegrationInstallationTokenRequest {
	return IntegrationsApiCreateIntegrationInstallationTokenRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
//
//	@return APITemporaryToken
func (a *IntegrationsApiService) CreateIntegrationInstallationTokenExecute(r IntegrationsApiCreateIntegrationInstallationTokenRequest) (*APITemporaryToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *APITemporaryToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.CreateIntegrationInstallationToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiGetIntegrationByNameRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
}

func (r IntegrationsApiGetIntegrationByNameRequest) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.GetIntegrationByNameExecute(r)
}

/*
GetIntegrationByName Get a specific integration by its name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiGetIntegrationByNameRequest
*/
func (a *IntegrationsApiService) GetIntegrationByName(ctx context.Context, integrationName string) IntegrationsApiGetIntegrationByNameRequest {
	return IntegrationsApiGetIntegrationByNameRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return Integration
func (a *IntegrationsApiService) GetIntegrationByNameExecute(r IntegrationsApiGetIntegrationByNameRequest) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.GetIntegrationByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiGetIntegrationEntitiesRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	installationId  string
}

func (r IntegrationsApiGetIntegrationEntitiesRequest) Execute() (*GetIntegrationEntities200Response, *http.Response, error) {
	return r.ApiService.GetIntegrationEntitiesExecute(r)
}

/*
GetIntegrationEntities List entities managed by an integration in an installation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiGetIntegrationEntitiesRequest
*/
func (a *IntegrationsApiService) GetIntegrationEntities(ctx context.Context, integrationName string, installationId string) IntegrationsApiGetIntegrationEntitiesRequest {
	return IntegrationsApiGetIntegrationEntitiesRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
//
//	@return GetIntegrationEntities200Response
func (a *IntegrationsApiService) GetIntegrationEntitiesExecute(r IntegrationsApiGetIntegrationEntitiesRequest) (*GetIntegrationEntities200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIntegrationEntities200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.GetIntegrationEntities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}/entities"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiGetIntegrationEventRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	eventId         string
}

func (r IntegrationsApiGetIntegrationEventRequest) Execute() (*GetIntegrationEvent200Response, *http.Response, error) {
	return r.ApiService.GetIntegrationEventExecute(r)
}

/*
GetIntegrationEvent Get a specific integration event by its id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param eventId ID of the integration event
	@return IntegrationsApiGetIntegrationEventRequest
*/
func (a *IntegrationsApiService) GetIntegrationEvent(ctx context.Context, integrationName string, eventId string) IntegrationsApiGetIntegrationEventRequest {
	return IntegrationsApiGetIntegrationEventRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		eventId:         eventId,
	}
}

// Execute executes the request
//
//	@return GetIntegrationEvent200Response
func (a *IntegrationsApiService) GetIntegrationEventExecute(r IntegrationsApiGetIntegrationEventRequest) (*GetIntegrationEvent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIntegrationEvent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.GetIntegrationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiGetIntegrationInstallationByIdRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	installationId  string
}

func (r IntegrationsApiGetIntegrationInstallationByIdRequest) Execute() (*IntegrationInstallation, *http.Response, error) {
	return r.ApiService.GetIntegrationInstallationByIdExecute(r)
}

/*
GetIntegrationInstallationById Get a specific integration's installation by its ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiGetIntegrationInstallationByIdRequest
*/
func (a *IntegrationsApiService) GetIntegrationInstallationById(ctx context.Context, integrationName string, installationId string) IntegrationsApiGetIntegrationInstallationByIdRequest {
	return IntegrationsApiGetIntegrationInstallationByIdRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
//
//	@return IntegrationInstallation
func (a *IntegrationsApiService) GetIntegrationInstallationByIdExecute(r IntegrationsApiGetIntegrationInstallationByIdRequest) (*IntegrationInstallation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntegrationInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.GetIntegrationInstallationById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiInstallIntegrationRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	integrationName    string
	organizationTarget *OrganizationTarget
}

func (r IntegrationsApiInstallIntegrationRequest) OrganizationTarget(organizationTarget OrganizationTarget) IntegrationsApiInstallIntegrationRequest {
	r.organizationTarget = &organizationTarget
	return r
}

func (r IntegrationsApiInstallIntegrationRequest) Execute() (*IntegrationInstallation, *http.Response, error) {
	return r.ApiService.InstallIntegrationExecute(r)
}

/*
InstallIntegration Install integration on a target organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiInstallIntegrationRequest
*/
func (a *IntegrationsApiService) InstallIntegration(ctx context.Context, integrationName string) IntegrationsApiInstallIntegrationRequest {
	return IntegrationsApiInstallIntegrationRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return IntegrationInstallation
func (a *IntegrationsApiService) InstallIntegrationExecute(r IntegrationsApiInstallIntegrationRequest) (*IntegrationInstallation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntegrationInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.InstallIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.organizationTarget == nil {
		return localVarReturnValue, nil, reportError("organizationTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationTarget
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiListIntegrationEventsRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	page            *string
	limit           *float32
}

// Identifier of the page results to fetch.
func (r IntegrationsApiListIntegrationEventsRequest) Page(page string) IntegrationsApiListIntegrationEventsRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r IntegrationsApiListIntegrationEventsRequest) Limit(limit float32) IntegrationsApiListIntegrationEventsRequest {
	r.limit = &limit
	return r
}

func (r IntegrationsApiListIntegrationEventsRequest) Execute() (*ListIntegrationEvents200Response, *http.Response, error) {
	return r.ApiService.ListIntegrationEventsExecute(r)
}

/*
ListIntegrationEvents List all integration events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiListIntegrationEventsRequest
*/
func (a *IntegrationsApiService) ListIntegrationEvents(ctx context.Context, integrationName string) IntegrationsApiListIntegrationEventsRequest {
	return IntegrationsApiListIntegrationEventsRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return ListIntegrationEvents200Response
func (a *IntegrationsApiService) ListIntegrationEventsExecute(r IntegrationsApiListIntegrationEventsRequest) (*ListIntegrationEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntegrationEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.ListIntegrationEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiListIntegrationInstallationsRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	page            *string
	limit           *float32
	externalId      *string
}

// Identifier of the page results to fetch.
func (r IntegrationsApiListIntegrationInstallationsRequest) Page(page string) IntegrationsApiListIntegrationInstallationsRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r IntegrationsApiListIntegrationInstallationsRequest) Limit(limit float32) IntegrationsApiListIntegrationInstallationsRequest {
	r.limit = &limit
	return r
}

// External Id to filter by
func (r IntegrationsApiListIntegrationInstallationsRequest) ExternalId(externalId string) IntegrationsApiListIntegrationInstallationsRequest {
	r.externalId = &externalId
	return r
}

func (r IntegrationsApiListIntegrationInstallationsRequest) Execute() (*ListIntegrationInstallations200Response, *http.Response, error) {
	return r.ApiService.ListIntegrationInstallationsExecute(r)
}

/*
ListIntegrationInstallations Fetch a list of installations of an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiListIntegrationInstallationsRequest
*/
func (a *IntegrationsApiService) ListIntegrationInstallations(ctx context.Context, integrationName string) IntegrationsApiListIntegrationInstallationsRequest {
	return IntegrationsApiListIntegrationInstallationsRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return ListIntegrationInstallations200Response
func (a *IntegrationsApiService) ListIntegrationInstallationsExecute(r IntegrationsApiListIntegrationInstallationsRequest) (*ListIntegrationInstallations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntegrationInstallations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.ListIntegrationInstallations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiListIntegrationSpaceInstallationsRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	page            *string
	limit           *float32
	externalId      *string
}

// Identifier of the page results to fetch.
func (r IntegrationsApiListIntegrationSpaceInstallationsRequest) Page(page string) IntegrationsApiListIntegrationSpaceInstallationsRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r IntegrationsApiListIntegrationSpaceInstallationsRequest) Limit(limit float32) IntegrationsApiListIntegrationSpaceInstallationsRequest {
	r.limit = &limit
	return r
}

// External Id to filter by
func (r IntegrationsApiListIntegrationSpaceInstallationsRequest) ExternalId(externalId string) IntegrationsApiListIntegrationSpaceInstallationsRequest {
	r.externalId = &externalId
	return r
}

func (r IntegrationsApiListIntegrationSpaceInstallationsRequest) Execute() (*ListIntegrationSpaceInstallations200Response, *http.Response, error) {
	return r.ApiService.ListIntegrationSpaceInstallationsExecute(r)
}

/*
ListIntegrationSpaceInstallations Fetch a list of space installations of an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiListIntegrationSpaceInstallationsRequest
*/
func (a *IntegrationsApiService) ListIntegrationSpaceInstallations(ctx context.Context, integrationName string) IntegrationsApiListIntegrationSpaceInstallationsRequest {
	return IntegrationsApiListIntegrationSpaceInstallationsRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return ListIntegrationSpaceInstallations200Response
func (a *IntegrationsApiService) ListIntegrationSpaceInstallationsExecute(r IntegrationsApiListIntegrationSpaceInstallationsRequest) (*ListIntegrationSpaceInstallations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntegrationSpaceInstallations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.ListIntegrationSpaceInstallations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiListIntegrationsRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	page       *string
	limit      *float32
}

// Identifier of the page results to fetch.
func (r IntegrationsApiListIntegrationsRequest) Page(page string) IntegrationsApiListIntegrationsRequest {
	r.page = &page
	return r
}

// The number of results per page
func (r IntegrationsApiListIntegrationsRequest) Limit(limit float32) IntegrationsApiListIntegrationsRequest {
	r.limit = &limit
	return r
}

func (r IntegrationsApiListIntegrationsRequest) Execute() (*ListIntegrations200Response, *http.Response, error) {
	return r.ApiService.ListIntegrationsExecute(r)
}

/*
ListIntegrations List all public integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IntegrationsApiListIntegrationsRequest
*/
func (a *IntegrationsApiService) ListIntegrations(ctx context.Context) IntegrationsApiListIntegrationsRequest {
	return IntegrationsApiListIntegrationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListIntegrations200Response
func (a *IntegrationsApiService) ListIntegrationsExecute(r IntegrationsApiListIntegrationsRequest) (*ListIntegrations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntegrations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.ListIntegrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiListSpaceIntegrationsBlocksRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	spaceId    string
}

func (r IntegrationsApiListSpaceIntegrationsBlocksRequest) Execute() ([]SpaceIntegrationBlocksInner, *http.Response, error) {
	return r.ApiService.ListSpaceIntegrationsBlocksExecute(r)
}

/*
ListSpaceIntegrationsBlocks List integrations blocks for a space

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId The unique id of the space
	@return IntegrationsApiListSpaceIntegrationsBlocksRequest
*/
func (a *IntegrationsApiService) ListSpaceIntegrationsBlocks(ctx context.Context, spaceId string) IntegrationsApiListSpaceIntegrationsBlocksRequest {
	return IntegrationsApiListSpaceIntegrationsBlocksRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []SpaceIntegrationBlocksInner
func (a *IntegrationsApiService) ListSpaceIntegrationsBlocksExecute(r IntegrationsApiListSpaceIntegrationsBlocksRequest) ([]SpaceIntegrationBlocksInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SpaceIntegrationBlocksInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.ListSpaceIntegrationsBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{spaceId}/integration-blocks"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiPublishIntegrationRequest struct {
	ctx                       context.Context
	ApiService                *IntegrationsApiService
	integrationName           string
	requestPublishIntegration *RequestPublishIntegration
}

func (r IntegrationsApiPublishIntegrationRequest) RequestPublishIntegration(requestPublishIntegration RequestPublishIntegration) IntegrationsApiPublishIntegrationRequest {
	r.requestPublishIntegration = &requestPublishIntegration
	return r
}

func (r IntegrationsApiPublishIntegrationRequest) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.PublishIntegrationExecute(r)
}

/*
PublishIntegration Publish an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiPublishIntegrationRequest
*/
func (a *IntegrationsApiService) PublishIntegration(ctx context.Context, integrationName string) IntegrationsApiPublishIntegrationRequest {
	return IntegrationsApiPublishIntegrationRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
//
//	@return Integration
func (a *IntegrationsApiService) PublishIntegrationExecute(r IntegrationsApiPublishIntegrationRequest) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.PublishIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestPublishIntegration == nil {
		return localVarReturnValue, nil, reportError("requestPublishIntegration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestPublishIntegration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsApiRemoveIntegrationDevSpaceRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	spaceId         string
}

func (r IntegrationsApiRemoveIntegrationDevSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveIntegrationDevSpaceExecute(r)
}

/*
RemoveIntegrationDevSpace Remove the development space for an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param spaceId The unique id of the space
	@return IntegrationsApiRemoveIntegrationDevSpaceRequest
*/
func (a *IntegrationsApiService) RemoveIntegrationDevSpace(ctx context.Context, integrationName string, spaceId string) IntegrationsApiRemoveIntegrationDevSpaceRequest {
	return IntegrationsApiRemoveIntegrationDevSpaceRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		spaceId:         spaceId,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) RemoveIntegrationDevSpaceExecute(r IntegrationsApiRemoveIntegrationDevSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.RemoveIntegrationDevSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/spaces/{spaceId}/dev"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IntegrationsApiSyncIntegrationEntitiesRequest struct {
	ctx                            context.Context
	ApiService                     *IntegrationsApiService
	integrationName                string
	installationId                 string
	syncIntegrationEntitiesRequest *SyncIntegrationEntitiesRequest
}

func (r IntegrationsApiSyncIntegrationEntitiesRequest) SyncIntegrationEntitiesRequest(syncIntegrationEntitiesRequest SyncIntegrationEntitiesRequest) IntegrationsApiSyncIntegrationEntitiesRequest {
	r.syncIntegrationEntitiesRequest = &syncIntegrationEntitiesRequest
	return r
}

func (r IntegrationsApiSyncIntegrationEntitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncIntegrationEntitiesExecute(r)
}

/*
SyncIntegrationEntities Update all entities for an integration installation. Entities will be created and updated, missing entities will be deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiSyncIntegrationEntitiesRequest
*/
func (a *IntegrationsApiService) SyncIntegrationEntities(ctx context.Context, integrationName string, installationId string) IntegrationsApiSyncIntegrationEntitiesRequest {
	return IntegrationsApiSyncIntegrationEntitiesRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) SyncIntegrationEntitiesExecute(r IntegrationsApiSyncIntegrationEntitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.SyncIntegrationEntities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}/entities"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncIntegrationEntitiesRequest == nil {
		return nil, reportError("syncIntegrationEntitiesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncIntegrationEntitiesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IntegrationsApiUninstallIntegrationRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
	installationId  string
}

func (r IntegrationsApiUninstallIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UninstallIntegrationExecute(r)
}

/*
UninstallIntegration Uninstall the integration from a target organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiUninstallIntegrationRequest
*/
func (a *IntegrationsApiService) UninstallIntegration(ctx context.Context, integrationName string, installationId string) IntegrationsApiUninstallIntegrationRequest {
	return IntegrationsApiUninstallIntegrationRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) UninstallIntegrationExecute(r IntegrationsApiUninstallIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.UninstallIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IntegrationsApiUnpublishIntegrationRequest struct {
	ctx             context.Context
	ApiService      *IntegrationsApiService
	integrationName string
}

func (r IntegrationsApiUnpublishIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnpublishIntegrationExecute(r)
}

/*
UnpublishIntegration Unpublish an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@return IntegrationsApiUnpublishIntegrationRequest
*/
func (a *IntegrationsApiService) UnpublishIntegration(ctx context.Context, integrationName string) IntegrationsApiUnpublishIntegrationRequest {
	return IntegrationsApiUnpublishIntegrationRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) UnpublishIntegrationExecute(r IntegrationsApiUnpublishIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.UnpublishIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IntegrationsApiUpdateIntegrationDevSpaceRequest struct {
	ctx                              context.Context
	ApiService                       *IntegrationsApiService
	integrationName                  string
	spaceId                          string
	updateIntegrationDevSpaceRequest *UpdateIntegrationDevSpaceRequest
}

func (r IntegrationsApiUpdateIntegrationDevSpaceRequest) UpdateIntegrationDevSpaceRequest(updateIntegrationDevSpaceRequest UpdateIntegrationDevSpaceRequest) IntegrationsApiUpdateIntegrationDevSpaceRequest {
	r.updateIntegrationDevSpaceRequest = &updateIntegrationDevSpaceRequest
	return r
}

func (r IntegrationsApiUpdateIntegrationDevSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateIntegrationDevSpaceExecute(r)
}

/*
UpdateIntegrationDevSpace Update the development space for an integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param spaceId The unique id of the space
	@return IntegrationsApiUpdateIntegrationDevSpaceRequest
*/
func (a *IntegrationsApiService) UpdateIntegrationDevSpace(ctx context.Context, integrationName string, spaceId string) IntegrationsApiUpdateIntegrationDevSpaceRequest {
	return IntegrationsApiUpdateIntegrationDevSpaceRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		spaceId:         spaceId,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) UpdateIntegrationDevSpaceExecute(r IntegrationsApiUpdateIntegrationDevSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.UpdateIntegrationDevSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/spaces/{spaceId}/dev"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntegrationDevSpaceRequest == nil {
		return nil, reportError("updateIntegrationDevSpaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntegrationDevSpaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetChangeRequestById404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IntegrationsApiUpdateIntegrationInstallationRequest struct {
	ctx                                  context.Context
	ApiService                           *IntegrationsApiService
	integrationName                      string
	installationId                       string
	requestUpdateIntegrationInstallation *RequestUpdateIntegrationInstallation
}

func (r IntegrationsApiUpdateIntegrationInstallationRequest) RequestUpdateIntegrationInstallation(requestUpdateIntegrationInstallation RequestUpdateIntegrationInstallation) IntegrationsApiUpdateIntegrationInstallationRequest {
	r.requestUpdateIntegrationInstallation = &requestUpdateIntegrationInstallation
	return r
}

func (r IntegrationsApiUpdateIntegrationInstallationRequest) Execute() (*IntegrationInstallation, *http.Response, error) {
	return r.ApiService.UpdateIntegrationInstallationExecute(r)
}

/*
UpdateIntegrationInstallation Update external IDs and configurations of an integration's installation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationName Name of the integration
	@param installationId Identifier of the installation
	@return IntegrationsApiUpdateIntegrationInstallationRequest
*/
func (a *IntegrationsApiService) UpdateIntegrationInstallation(ctx context.Context, integrationName string, installationId string) IntegrationsApiUpdateIntegrationInstallationRequest {
	return IntegrationsApiUpdateIntegrationInstallationRequest{
		ApiService:      a,
		ctx:             ctx,
		integrationName: integrationName,
		installationId:  installationId,
	}
}

// Execute executes the request
//
//	@return IntegrationInstallation
func (a *IntegrationsApiService) UpdateIntegrationInstallationExecute(r IntegrationsApiUpdateIntegrationInstallationRequest) (*IntegrationInstallation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntegrationInstallation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.UpdateIntegrationInstallation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationName}/installations/{installationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationName"+"}", url.PathEscape(parameterValueToString(r.integrationName, "integrationName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installationId"+"}", url.PathEscape(parameterValueToString(r.installationId, "installationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestUpdateIntegrationInstallation == nil {
		return localVarReturnValue, nil, reportError("requestUpdateIntegrationInstallation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestUpdateIntegrationInstallation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
